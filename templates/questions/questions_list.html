{% extends 'core/base.html' %}

{% block content %}
	<main>
		<div class="questions-container" id="questions-container"
		     data-user-id="{{ request.user.pk|default:'null' }}"
		     data-has-questions="{{ has_questions|yesno:'true,false' }}">

			<div id="tag-filter-container" aria-label="Filter questions by tags" role="region" style="margin-bottom: 1rem;">
				<span style="font-weight: 600; margin-right: 0.75rem;">Filter by tag:</span>
				{% for tag in tags %}
					<button type="button" class="btn btn-tag-filter" data-tag-id="{{ tag.id }}">{{ tag.name }}</button>
				{% endfor %}
				<button type="button" class="btn btn-tag-filter btn-clear" style="margin-left: 1rem;">Clear Filter</button>
			</div>

			<!-- Search Bar -->
			<form id="rest-search-form" autocomplete="off" class="top-bar-search site-search-form">
				<input
						type="text"
						id="rest-search-input"
						name="search"
						placeholder="Search questions..."
						aria-label="Search questions"
						class="site-search-input"
				/>
				<button type="submit" class="site-search-btn">Search</button>
			</form>

			<!-- Status Message (loading, empty, or error) -->
			<div id="questions-status-message" aria-live="polite"></div>

			<!-- Questions List (populated by JS) -->
			<ul class="questions-list" id="question-list-container"></ul>

			<!-- Pagination (populated by JS) -->
			<nav class="pagination" aria-label="Questions pagination"
			     id="pagination-container" {% if not is_paginated %}style="display:none"{% endif %}></nav>
		</div>

	<script>
		(function() {
			const container = document.getElementById('questions-container');
			const userIdRaw = container.dataset.userId;
			const userId = userIdRaw === 'null' ? null : parseInt(userIdRaw, 10);
			const hasQuestions = container.dataset.hasQuestions === "true";
			const apiEndpoint = "{% url 'question-search-api' %}";
			const questionList = document.getElementById('question-list-container');
			const paginationContainer = document.getElementById('pagination-container');
			const searchForm = document.getElementById('rest-search-form');
			const searchInput = document.getElementById('rest-search-input');
			const statusDiv = document.getElementById('questions-status-message');
			const tagFilterContainer = document.getElementById('tag-filter-container');
			let selectedTagIds = new Set();

			// ========== READ ALL PARAMS FROM URL ==========
			function getParamsFromUrl() {
				const urlParams = new URLSearchParams(window.location.search);
				const page = parseInt(urlParams.get('page')) || 1;
				const search = urlParams.get('search') || "";
				const tags = urlParams.getAll('tag');
				return { page, search, tags };
			}

			function syncUIToParams(params) {
				// Sync search input
				searchInput.value = params.search;
				// Sync tag selection
				selectedTagIds.clear();
				(params.tags || []).forEach(tagId => selectedTagIds.add(tagId));
				updateTagFilterButtons();
			}

			// ========== TAG FILTERS HANDLER ==========
			tagFilterContainer.addEventListener('click', (e) => {
				const button = e.target.closest('button.btn-tag-filter');
				if (!button) return;

				let page = 1;
				let search = searchInput.value.trim();

				if (button.classList.contains('btn-clear')) {
					selectedTagIds.clear();
				} else {
					const tagId = button.dataset.tagId;
					if (selectedTagIds.has(tagId)) {
						selectedTagIds.delete(tagId);
					} else {
						selectedTagIds.add(tagId);
					}
				}
				updateTagFilterButtons();
				pushUrlAndFetch({search, page, tags: Array.from(selectedTagIds)});
			});

			function updateTagFilterButtons() {
				tagFilterContainer.querySelectorAll('.btn-tag-filter').forEach(btn => {
					const tagId = btn.dataset.tagId;
					if (btn.classList.contains('btn-clear')) {
						btn.disabled = selectedTagIds.size === 0;
					} else if (selectedTagIds.has(tagId)) {
						btn.classList.add('selected');
					} else {
						btn.classList.remove('selected');
					}
				});
			}

			function truncate(text, maxLength) {
				return text.length <= maxLength ? text : text.substring(0, maxLength) + '...';
			}

			// ========== STATUS MESSAGE
			function setStatusMessage(htmlOrNull, statusType="info") {
				statusDiv.innerHTML = htmlOrNull ? `<div class="questions-status ${statusType}">${htmlOrNull}</div>` : "";
			}

			// ========== QUESTION ITEM
			function renderQuestionItem(q) {
				const container_a = document.createElement('a');
				container_a.href = `/questions/${q.id}/details/`;
				container_a.className = 'list_question_link';
				const li = document.createElement('li');
				container_a.append(li)
				li.className = 'question-item';

				const h2 = document.createElement('h2');
				h2.className = 'question-title';

				const a = document.createElement('a');
				a.href = `/questions/${q.id}/details/`;
				a.textContent = q.title;
				h2.appendChild(a);
				li.appendChild(h2);

				const p = document.createElement('p');
				p.className = 'question-body';
				p.textContent = truncate(q.body, 500);
				li.appendChild(p);

				return container_a;
			}

			// ========== PAGINATION
			function renderPagination(page, totalPages) {
				if (totalPages <= 1) {
					paginationContainer.style.display = 'none';
					paginationContainer.textContent = '';
					return;
				}
				paginationContainer.style.display = 'block';
				paginationContainer.textContent = '';

				const ul = document.createElement('ul');
				ul.className = 'pagination-links';

				function makePageLink(label, p, disabled = false, ariaLabel = null) {
					const li = document.createElement('li');
					if (disabled) {
						li.className = 'disabled';
						li.setAttribute('aria-disabled', 'true');
						li.textContent = label;
					} else {
						const a = document.createElement('a');
						a.href = '#';
						a.dataset.page = p;
						if (ariaLabel) {
							a.setAttribute('aria-label', ariaLabel);
						}
						a.textContent = label;
						li.appendChild(a);
					}
					return li;
				}

				ul.appendChild(page === 1 ? makePageLink("First", 1, true) : makePageLink("First", 1, false, "First page"));
				ul.appendChild(page === 1 ? makePageLink("Previous", page - 1, true) : makePageLink("Previous", page - 1, false, "Previous page"));

				const currentLi = document.createElement('li');
				currentLi.className = 'current-page';
				currentLi.setAttribute('aria-current', 'page');
				currentLi.textContent = `Page ${page} of ${totalPages}`;
				ul.appendChild(currentLi);

				ul.appendChild(page === totalPages ? makePageLink("Next", page + 1, true) : makePageLink("Next", page + 1, false, "Next page"));
				ul.appendChild(page === totalPages ? makePageLink("Last", totalPages, true) : makePageLink("Last", totalPages, false, "Last page"));

				paginationContainer.appendChild(ul);

				const form = document.createElement('form');
				form.id = 'pageJumpForm';
				form.method = 'get';
				form.className = 'page-jump-form';
				form.setAttribute('aria-label', 'Jump to page form');
				form.onsubmit = function(e) { e.preventDefault(); return false; };

				const label = document.createElement('label');
				label.setAttribute('for', 'page_number');
				label.className = 'page-jump-label';
				label.textContent = 'Go to page:';

				const input = document.createElement('input');
				input.type = 'number';
				input.id = 'page_number';
				input.name = 'page';
				input.value = page;
				input.required = true;
				input.className = 'page-jump-input';
				input.setAttribute('aria-describedby', 'pageJumpHelp');

				const button = document.createElement('button');
				button.type = 'submit';
				button.className = 'btn btn-go';
				button.textContent = 'Go';

				const small = document.createElement('small');
				small.id = 'pageJumpHelp';
				small.className = 'form-help-text';
				small.textContent = `Enter a page number between 1 and ${totalPages}`;

				form.appendChild(label);
				form.appendChild(input);
				form.appendChild(button);
				form.appendChild(small);

				paginationContainer.appendChild(form);

				ul.querySelectorAll('a[data-page]').forEach(link => {
					link.addEventListener('click', e => {
						e.preventDefault();
						const selectedPage = parseInt(link.dataset.page, 10);
						if (selectedPage && selectedPage !== parseInt(input.value, 10) && selectedPage >= 1 && selectedPage <= totalPages) {
							pushUrlAndFetch({search:searchInput.value.trim(), page:selectedPage, tags:Array.from(selectedTagIds)});
						}
					});
				});

				form.addEventListener('submit', e => {
					e.preventDefault();
					let val = parseInt(input.value, 10);
					if (isNaN(val) || val < 1) val = 1;
					if (val > totalPages) val = totalPages;
					pushUrlAndFetch({search:searchInput.value.trim(), page:val, tags:Array.from(selectedTagIds)});
				});
			}

			// ========== FETCH AND DISPLAY ==========
			async function fetchQuestions(search = "", page = 1, tags = []) {
				searchInput.disabled = true;
				searchForm.querySelector('button[type="submit"]').disabled = true;

				let loaderTimeout = setTimeout(() => {
					setStatusMessage('<span class="spinner"></span> Loading...', 'loading');
					paginationContainer.style.display = 'none';
					questionList.textContent = '';
				}, 300);

				const params = new URLSearchParams();
				if (search) params.append('search', search);
				if (page) params.append('page', page);
				tags.forEach(tagId => params.append('tag', tagId));

				try {
					const response = await fetch(`${apiEndpoint}?${params.toString()}`, {
						headers: { 'Accept': 'application/json' },
						credentials: 'same-origin',
					});

					clearTimeout(loaderTimeout);

					if (!response.ok) throw new Error('Failed to fetch questions');
					const data = await response.json();

					const results = data.results || [];
					const count = data.count || 0;
					const pageSize = data.page_size || (data.results ? data.results.length : 10);
					const totalPages = pageSize ? Math.ceil(count / pageSize) : 1;

					if (results.length === 0) {
						if (!hasQuestions) {
							setStatusMessage('<b>No questions have been posted yet.</b> &#128578;<br>Be the first to <a href="{% url "question_create" %}" class="ask-link">ask a question</a>!', 'empty');
						} else {
							setStatusMessage('<b>No questions found.</b> &#128577;<br>Try a different search or tag filter.', 'empty');
						}
						paginationContainer.style.display = 'none';
						questionList.textContent = '';
					} else {
						setStatusMessage(null);
						questionList.textContent = '';
						results.forEach(q => {
							questionList.appendChild(renderQuestionItem(q));
						});
						renderPagination(page, totalPages);
					}
				} catch (error) {
					clearTimeout(loaderTimeout);
					setStatusMessage('<b>Error loading questions.</b> &#9888;<br>Please try again.', 'error');
					paginationContainer.style.display = 'none';
					questionList.textContent = '';
					console.error(error);
				} finally {
					searchInput.disabled = false;
					searchForm.querySelector('button[type="submit"]').disabled = false;
					searchInput.focus();
				}
			}

			function debounce(func, wait) {
				let timeout;
				return function(...args) {
					clearTimeout(timeout);
					timeout = setTimeout(() => func.apply(this, args), wait);
				};
			}

			searchInput.addEventListener('input', debounce(() => {
				pushUrlAndFetch({search:searchInput.value.trim(), page:1, tags:Array.from(selectedTagIds)});
			}, 300));

			searchForm.addEventListener('submit', e => {
				e.preventDefault();
				pushUrlAndFetch({search:searchInput.value.trim(), page:1, tags:Array.from(selectedTagIds)});
			});

			// Unified function to update URL and call fetchQuestions with history.pushState
			function pushUrlAndFetch({search, page, tags}) {
				const url = new URL(window.location.href);
				url.searchParams.set('page', page);
				if (search) {
					url.searchParams.set('search', search);
				} else {
					url.searchParams.delete('search');
				}
				url.searchParams.delete('tag');
				(tags || []).forEach(tagId => url.searchParams.append('tag', tagId));
				// IMPORTANT: use pushState so Back/Forward works per navigation step
				history.pushState(null, '', url);
				syncUIToParams({search, tags, page});
				fetchQuestions(search, page, tags);
			}

			// Respond to browser Back/Forward navigation
			window.addEventListener('popstate', function() {
				const params = getParamsFromUrl();
				syncUIToParams(params);
				fetchQuestions(params.search, params.page, params.tags);
			});

			// ========== INITIAL LOAD ==========

			// On the first load, set UI from the url and load correct content for URL params
			const initialParams = getParamsFromUrl();
			// Use replaceState so refresh/bookmark simply sets the URL quietly
			const url = new URL(window.location.href);
			url.searchParams.set('page', initialParams.page);
			if (initialParams.search) {
				url.searchParams.set('search', initialParams.search);
			} else {
				url.searchParams.delete('search');
			}
			url.searchParams.delete('tag');
			(initialParams.tags || []).forEach(tagId => url.searchParams.append('tag', tagId));
			history.replaceState(null, '', url);
			syncUIToParams(initialParams);
			fetchQuestions(initialParams.search, initialParams.page, initialParams.tags);

		})();
	</script>
	</main>
{% endblock %}
