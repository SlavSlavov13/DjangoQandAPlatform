{% extends 'core/base.html' %}

{% block content %}
	<div class="questions-container" id="questions-container" data-user-id="{{ request.user.pk|default:'null' }}">
		<!-- Search Bar -->
		<form id="rest-search-form" autocomplete="off">
			<input
					type="text"
					id="rest-search-input"
					name="search"
					placeholder="Search questions..."
					aria-label="Search questions"
			/>
			<button type="submit">Search</button>
		</form>

		<!-- Questions List Container (to be populated by JS) -->
		<ul class="questions-list" id="question-list-container">
			{% for question in questions %}
				<li class="question-item">
					<h2 class="question-title">{{ question.title|escape }}</h2>
					<p class="question-body">{{ question.body|linebreaksbr|safe }}</p>
					{% if question.author.pk == request.user.pk %}
						<div class="question-actions">
							<a class="btn btn-edit" href="{% url 'question_update' question.pk %}">Edit</a>
							<a class="btn btn-delete" href="{% url 'question_delete' question.pk %}">Delete</a>
						</div>
					{% endif %}
				</li>
			{% empty %}
				<li class="no-questions">No questions found.</li>
			{% endfor %}
		</ul>

		<!-- Pagination -->
		<nav class="pagination" aria-label="Questions pagination" id="pagination-container" {% if not is_paginated %}style="display:none"{% endif %}>
			<!-- Pagination links will be rendered here by JS -->
		</nav>
	</div>

	<script>
		(function() {
			const container = document.getElementById('questions-container');
			const userIdRaw = container.dataset.userId;
			const userId = userIdRaw === 'null' ? null : parseInt(userIdRaw, 10);

			const apiEndpoint = "{% url 'question_search_api' %}";

			const questionList = document.getElementById('question-list-container');
			const paginationContainer = document.getElementById('pagination-container');
			const searchForm = document.getElementById('rest-search-form');
			const searchInput = document.getElementById('rest-search-input');

			let currentSearch = "";
			let currentPage = 1;

			// Truncate text to maxLength with ellipsis
			function truncate(text, maxLength) {
				return text.length <= maxLength ? text : text.substring(0, maxLength) + '...';
			}

			// Render a single question item using DOM methods to avoid innerHTML and escape safely
			function renderQuestionItem(q) {
				const li = document.createElement('li');
				li.className = 'question-item';

				const h2 = document.createElement('h2');
				h2.className = 'question-title';

				// Create link for question title (linking to update page)
				const a = document.createElement('a');
				a.href = `/questions/${q.id}/update/`;  // Dynamic URL construction
				a.textContent = q.title;  // textContent escapes automatically
				h2.appendChild(a);
				li.appendChild(h2);

				const p = document.createElement('p');
				p.className = 'question-body';
				p.textContent = truncate(q.body, 500); // safe truncation and text insertion
				li.appendChild(p);

				if (q.author_pk === userId) {
					const divActions = document.createElement('div');
					divActions.className = 'question-actions';

					// Edit button
					const editLink = document.createElement('a');
					editLink.className = 'btn btn-edit';
					editLink.href = `/questions/${q.id}/update/`;  // Dynamic URL
					editLink.textContent = 'Edit';

					// Delete button
					const deleteLink = document.createElement('a');
					deleteLink.className = 'btn btn-delete';
					deleteLink.href = `/questions/${q.id}/delete/`;  // Dynamic URL
					deleteLink.textContent = 'Delete';

					divActions.appendChild(editLink);
					divActions.appendChild(deleteLink);
					li.appendChild(divActions);
				}

				return li;
			}

			// Create pagination elements safely without innerHTML
			function renderPagination(page, totalPages) {
				if (totalPages <= 1) {
					paginationContainer.style.display = 'none';
					paginationContainer.textContent = '';
					return;
				}
				paginationContainer.style.display = 'block';
				paginationContainer.textContent = ''; // Clear previous content

				const ul = document.createElement('ul');
				ul.className = 'pagination-links';

				function makePageLink(label, p, disabled = false, ariaLabel = null) {
					const li = document.createElement('li');
					if (disabled) {
						li.className = 'disabled';
						li.setAttribute('aria-disabled', 'true');
						li.textContent = label;
					} else {
						const a = document.createElement('a');
						a.href = '#';
						a.dataset.page = p;
						if (ariaLabel) {
							a.setAttribute('aria-label', ariaLabel);
						}
						a.textContent = label;
						li.appendChild(a);
					}
					return li;
				}

				ul.appendChild(page === 1 ? makePageLink("First", 1, true) : makePageLink("First", 1, false, "First page"));
				ul.appendChild(page === 1 ? makePageLink("Previous", page - 1, true) : makePageLink("Previous", page - 1, false, "Previous page"));

				const currentLi = document.createElement('li');
				currentLi.className = 'current-page';
				currentLi.setAttribute('aria-current', 'page');
				currentLi.textContent = `Page ${page} of ${totalPages}`;
				ul.appendChild(currentLi);

				ul.appendChild(page === totalPages ? makePageLink("Next", page + 1, true) : makePageLink("Next", page + 1, false, "Next page"));
				ul.appendChild(page === totalPages ? makePageLink("Last", totalPages, true) : makePageLink("Last", totalPages, false, "Last page"));

				paginationContainer.appendChild(ul);

				// Page jump form (constructed via DOM)
				const form = document.createElement('form');
				form.id = 'pageJumpForm';
				form.method = 'get';
				form.className = 'page-jump-form';
				form.setAttribute('aria-label', 'Jump to page form');
				form.onsubmit = function(e) { e.preventDefault(); return false; };

				const label = document.createElement('label');
				label.setAttribute('for', 'page_number');
				label.className = 'page-jump-label';
				label.textContent = 'Go to page:';

				const input = document.createElement('input');
				input.type = 'number';
				input.id = 'page_number';
				input.name = 'page';
				input.min = 1;
				input.max = totalPages;
				input.value = page;
				input.required = true;
				input.className = 'page-jump-input';
				input.setAttribute('aria-describedby', 'pageJumpHelp');

				const button = document.createElement('button');
				button.type = 'submit';
				button.className = 'btn btn-go';
				button.textContent = 'Go';

				const small = document.createElement('small');
				small.id = 'pageJumpHelp';
				small.className = 'form-help-text';
				small.textContent = `Enter a page number between 1 and ${totalPages}`;

				form.appendChild(label);
				form.appendChild(input);
				form.appendChild(button);
				form.appendChild(small);

				paginationContainer.appendChild(form);

				// Event listeners for links
				ul.querySelectorAll('a[data-page]').forEach(link => {
					link.addEventListener('click', e => {
						e.preventDefault();
						const selectedPage = parseInt(link.dataset.page, 10);
						if (selectedPage && selectedPage !== currentPage && selectedPage >= 1 && selectedPage <= totalPages) {
							fetchQuestions(currentSearch, selectedPage);
						}
					});
				});

				// Page jump form submission
				form.addEventListener('submit', e => {
					e.preventDefault();
					let val = parseInt(input.value, 10);
					if (isNaN(val) || val < 1) val = 1;
					if (val > totalPages) val = totalPages;
					fetchQuestions(currentSearch, val);
				});
			}

			// Fetch questions from API with optional search and page
			async function fetchQuestions(search = "", page = 1) {
				currentSearch = search;
				currentPage = page;

				searchInput.disabled = true;
				searchForm.querySelector('button[type="submit"]').disabled = true;

				let loaderTimeout = setTimeout(() => {
					questionList.textContent = 'Loading...';
					paginationContainer.style.display = 'none';
				}, 300);

				const params = new URLSearchParams();
				if (search) params.append('search', search);
				if (page) params.append('page', page);

				try {
					const response = await fetch(`${apiEndpoint}?${params.toString()}`, {
						headers: { 'Accept': 'application/json' },
						credentials: 'same-origin',
					});

					clearTimeout(loaderTimeout);

					if (!response.ok) throw new Error('Failed to fetch questions');

					const data = await response.json();

					const results = data.results || [];
					const count = data.count || 0;
					const pageSize = data.page_size || 10;

					if (results.length === 0) {
						questionList.textContent = 'No questions found.';
						paginationContainer.style.display = 'none';
					} else {
						questionList.textContent = '';
						results.forEach(q => {
							questionList.appendChild(renderQuestionItem(q));
						});
						const totalPages = Math.ceil(count / pageSize);
						renderPagination(page, totalPages);
					}
				} catch (error) {
					clearTimeout(loaderTimeout);
					questionList.textContent = 'Error loading questions.';
					paginationContainer.style.display = 'none';
					console.error(error);
				} finally {
					searchInput.disabled = false;
					searchForm.querySelector('button[type="submit"]').disabled = false;
					searchInput.focus();
				}
			}

			// Debounce function
			function debounce(func, wait) {
				let timeout;
				return function(...args) {
					clearTimeout(timeout);
					timeout = setTimeout(() => func.apply(this, args), wait);
				};
			}

			// Live search on input with debounce
			searchInput.addEventListener('input', debounce(() => {
				fetchQuestions(searchInput.value.trim(), 1);
			}, 300));

			// Form submit handler
			searchForm.addEventListener('submit', e => {
				e.preventDefault();
				fetchQuestions(searchInput.value.trim(), 1);
			});

			// Initial load immediately
			fetchQuestions("", 1);

		})();
	</script>

{% endblock %}
